---
alwaysApply: true
---

# Контекст проекта и правила работы с AI

## Кто я и мои цели

**Роль:** Закупщик, 23 года, хочу поменять мир хореки к лучшему через новые инструменты на нашем рынке с высокой детализацией, поэтому отчасти разработчик ETL-процессов для интеграции iiko с DataLens через Neon (PostgreSQL)

**Текущий проект:** datalens-iiko-etl — построение управленческого дашборда по инвентаризациям для анализа недостач/излишков, превышений норм отклонений и ключевых источников потерь по неделям и филиалам.

**Сильные стороны:** Понимаю структуру данных, логику бизнес-процессов, знаю что нужно бизнесу

**Слабые стороны:** Не программист, могу не знать всех тонкостей Python-библиотек, SQL, архитектуры и best practices. Нужна помощь с технической реализацией.

## Стратегические цели проекта

**Бизнес-цели:**
- Построить управленческий дашборд по инвентаризациям
- Ответить на вопросы: где недостачи/излишки, где превышена норма отклонений, где теряем деньги, какие товары — ключевые источники потерь
- Аналитика по неделям и филиалам без задвоений с корректной логикой инвентаризаций

**Технические цели:**
- Автоматизация еженедельной загрузки данных из iiko
- Надежность и идемпотентность (защита от дублей через source_hash)
- Корректная обработка инвентаризаций (только итоговые, без промежуточных)
- Простота поддержки и расширения
- Интеграция с GitHub Actions для автоматического запуска
- В будущем: динамика по товарам по неделям, анализ «начали работать с товаром → пошли ли недостачи вниз»

## Видение продукта

- **Дашборды** — верхушка айсберга. Основная точка входа для анализа (что происходит с инвентаризациями, где недостачи/излишки, отклонения, потери).
- **Алармы на основе данных дашбордов и витрин** — автоматические сигналы по заранее заданным правилам, которые помогают сразу увидеть проблемы:
  - **Не сохранены в инвентаризации** — есть движение товара, но нет INVENTORY_CORRECTION (несохранённые позиции).
  - **Неверно посчитаны в прошлой инвентаризации** — смена знака отклонения между последней и предпоследней инвентаризациями, превышение порога (примерно >40%).
  - **Пересорт в текущей инвентаризации** — позиции «перепутались» между собой внутри одной инвенты.
  - **Неправильная приёмка** — товар неправильно принят (перепутали на одном филиале, приняли другое на другом; требуется доп. логика по кейсам).
  - **ТОП-проверка актов и накладных** — проверка на задвоенные накладные, корректность списаний, актов приготовления и т.п.
- **Задачи в операционный контур** — подтверждённые алармы превращаются в задачи, например через Telegram-бота:
  - Пример: по лососю на филиале Авиагородок среднее отклонение за все недели было −2 кг, на текущей неделе −6 кг; на Домодедово такого пика нет → проблема локальна для Авиагородка → заводим задачу «делать ежедневную инвентаризацию по лососю и отслеживать результаты».

Итоговая цель: система не только показывает цифры, но и **сама подсвечивает отклонения и помогает превращать их в конкретные действия/задачи**.

## Архитектура проекта

**Поток данных (итоговый):**
```
iiko OLAP
   ↓
inventory_raw.olap_postings (RAW)
   ↓
inventory_core (очистка + агрегации + логика)
   ↓
inventory_mart (витрины под DataLens)
   ↓
DataLens (дашборды)
```

**Принцип:** Core — логика. Mart — формат. DataLens — визуал. Нельзя тащить бизнес-логику в BI и ломать core ради визуала.

**Структура таблиц Neon:** полный список схем, таблиц и колонок — в **`docs/neon-tables.md`**. При вопросах по данным, запросам и полям читать этот файл. Обновить схему: из корня проекта запустить `python scripts/dump_neon_schema.py` (нужен `.env` с NEON_*).

---

**1. RAW (`inventory_raw.olap_postings`):**
- Все проводки iiko. Типы транзакций: WRITEOFF, PRODUCTION, OUTGOING_INVOICE, SESSION_WRITEOFF, INVENTORY_CORRECTION, **INVOICE** (приход).
- Защита от дублей: `source_hash`, данные не дублируются.

**2. CORE (`inventory_core.*`):**
- `transactions` / `transactions_products` — нормализованная лента, SIGNED-логика.
- `weekly_movement_products` — движение по товарам (базовая витрина).
- `inventory_correction_clean_products` — ОЧИЩЕННАЯ инвентаризация (только итоговая).
- Флаг **«неверно посчитано в прошлой инвентаризации»**: сравнение последней и предпоследней инвентаризации, смена знака отклонения, превышение порога (например >40%).
- **Несохранённые позиции**: есть движение товара, но нет INVENTORY_CORRECTION → позиция не была сохранена в инвентаризации.

**3. MART (`inventory_mart.*`)** — витрины под DataLens:
- `weekly_deviation_products_money_v2` — денежная аналитика.
- `weekly_deviation_products_qty` — количественная аналитика.
- `sandbox_inventory_products` — песочница.
- Поля витрин: `is_wrong_prev_inventory`, `is_missing_inventory_position`, `week_label` (например Н5 (20.01–26.01)), `week_num`.
- ⚠️ В Neon при изменении колонок: **DROP + CREATE**. Не пересоздавать mart без проверки зависимостей. **Не использовать DROP CASCADE** без понимания — можно убить зависимости.

**4. DataLens — три вкладки дашборда:**
- **Вкладка 1 — Итоговая инвентаризация:** деньги, %, потенциальные потери; фильтр по филиалу; выбор недели; выбор диапазона дат.
- **Вкладка 2 — Анализ пути товара:** документы (INVOICE, PRODUCTION, WRITEOFF, OUTGOING_INVOICE), `qty_signed`, `money_signed`; фильтр по периоду.
- **Вкладка 3 — Песочница:** объединение money + qty, полный доступ к данным.

**Связи и агрегация в DataLens:** alias по department для фильтра филиала; в MONEY-датасете только _sum поля в чартах. Сортировка — только обычная таблица (поле в строках + поле сортировки + дубликат столбца).

## ETL — период выгрузки (важно)

- **includeLow = True, includeHigh = False** → дата **date_to не включается** в выгрузку.
- Для недели **20.01–26.01** нужно ставить **date_to = 27.01**, иначе инвентаризация не попадёт в выгрузку.
- Поддержка ручного периода: DATE_FROM / DATE_TO (в т.ч. через inputs в GitHub Actions). Логика авто-недели: Tue → Tue.

## Текущий статус

**Реализовано:**
- ✅ ETL: ручной период, типы транзакций (в т.ч. INVOICE), source_hash, без дублей
- ✅ RAW → CORE → MART → DataLens; флаги is_wrong_prev_inventory, is_missing_inventory_position
- ✅ Три вкладки дашборда: Итоговая инвентаризация, Анализ пути товара, Песочница
- ✅ Сортировка и агрегация в DataLens по принятой схеме

**Инструмент даёт:** системные отклонения, неверно пересчитанные позиции, несохранённые позиции, путь документа, приходы/списания, анализ нескольких недель, песочницу.

## Ошибки, которых избегать

1. **Неправильный период:** date_to не входит → для полной недели указывать date_to = следующий день. Всегда проверять период выгрузки.
2. **Рекурсия во вьюхах:** «infinite recursion detected» — view ссылается на саму себя. Всегда проверять FROM, не ссылаться на имя создаваемой вьюхи.
3. **DROP CASCADE:** может убить зависимости (чуть не убили mart). Всегда проверять зависимости, не использовать CASCADE вслепую.
4. **Фильтр по week_label:** week_label — строка, для сортировки/фильтрации по периоду использовать **week_start**. week_label — только для подписи.
5. **Эталон филиала:** не сравнивать филиалы по количеству позиций; эталон может отличаться. Сравнивать фактическое движение vs inventory_correction.

## Ключевые выводы (для AI)

- **Core = логика, Mart = формат, DataLens = визуал.** Не тащить бизнес-логику в BI, не ломать core ради визуала.
- **Период:** date_to исключающий → для недели 20.01–26.01 задавать date_to = 27.01.
- **Сортировка в DataLens:** только обычная таблица; фильтр по периоду — по week_start, не по week_label.
- **Neon:** DROP + CREATE при изменении колонок; не пересоздавать mart без проверки зависимостей; не использовать CASCADE без понимания.
- **Агрегация в DataLens:** фиксировать на уровне датасета (_sum и т.п.), MONEY и QTY симметричны.

## Как помогать

### Язык общения
- **Всегда отвечай на русском языке** (код и комментарии тоже на русском, если не указано иное)
- Используй технические термины, но объясняй сложные концепции простым языком

### Формат ответов
- **Давай готовый код**, а не только объяснения
- Предлагай архитектурные решения с обоснованием
- Если видишь потенциальные проблемы — предупреждай заранее
- При рефакторинге сохраняй обратную совместимость

### Подход к коду
- Следуй принципам DRY, но не переусложняй
- Добавляй комментарии к сложной логике (особенно к SIGNED-логике и обработке инвентаризаций)
- Используй type hints где это уместно
- Обрабатывай ошибки явно, не скрывай исключения
- При работе с DataLens: сортировка — только обычная таблица (не сводная); агрегацию фиксировать в датасете (_sum и т.п.), чтобы MONEY и QTY вели себя одинаково

### Работа с архитектурой
- **Core — логика, Mart — формат, DataLens — визуал.** Не переносить бизнес-логику в BI, не ломать core ради визуала.
- **Neon:** при изменении колонок — DROP + CREATE. Не пересоздавать mart без проверки зависимостей. Не использовать DROP CASCADE без понимания.
- **DataLens:** фильтр по периоду — по week_start, не по строковому week_label. Если «дробит» строки — проверять агрегацию в датасете.
- Понимать логику инвентаризаций: учитывать только итоговые; date_to в ETL — исключающий (для полной недели +1 день).

## Предпочтения по результату

- **Конкретика важнее общих советов** — лучше показать код, чем описать концепцию
- **Готовый код > инструкции** — если можно сразу написать, пиши
- **Git:** коммиты и push делает пользователь сам. AI не выполняет `git commit` / `git push` — только подсказывает, что добавить в коммит и какое сообщение написать.
- **Безопасность важна** — не хардкодить секреты, использовать env-переменные
- **Логирование** — добавляй информативные print/log для отладки в CI/CD

## Документация проекта

### Двухуровневая система документации

**Уровень 1 — корневой README.md:**
- Назначение: стратегическая навигация — структура папок, цели проекта, общая архитектура
- Когда читать: при необходимости общей картины проекта, при работе с новыми файлами, при рефакторинге
- Где находится: `README.md` в корне workspace

**Уровень 2 — readme в папках:**
- Назначение: тактический контекст — что лежит в папке, зачем, правила работы, ссылки на важные файлы
- Когда читать: при работе с файлами в конкретной папке, при поиске конфигов/секретов
- Где находится: `readme.txt` или `README.md` в каждой значимой папке

### Правила чтения документации для AI

1. **При необходимости общей картины:**
   - Сначала прочитать корневой `README.md`
   - При необходимости — `readme.txt` в нужных папках

2. **При работе с файлами в папке:**
   - Сначала прочитать `readme.txt` этой папки (если есть)
   - Затем работать с файлами

3. **При поиске по проекту:**
   - Опираться на readme в папках как на индекс
   - Не читать все файлы подряд, а использовать документацию для навигации

### Правила актуализации документации

**Корневой README.md обновлять:**
- При добавлении новых проектов/крупных разделов
- При изменении структуры верхнего уровня (новые папки в корне)
- По явному запросу пользователя («актуализируй readme», «обнови документацию»)
- **Важно:** сохранять краткость, не дублировать детали из этого правила

**Readme в папке обновлять:**
- При добавлении в папку подпапок или значимых файлов/модулей
- При изменении назначения папки
- По явному запросу пользователя («описать папку», «задокументировать эту папку»)
- **Важно:** сохранять уже написанную суть, добавлять/обновлять только изменившееся

**При обновлении документации:**
- Предлагать обновление, если видишь расхождение со структурой
- Выполнять обновление по запросу или при явных изменениях структуры
- Сохранять стиль и формат существующей документации

## База знаний по технологиям

**Дополнительная документация:** см. `.cursor/rules/datalens-iiko-knowledge.md` для детальной информации о:
- DataLens (сортировка, агрегации, LOD-выражения, ограничения)
- iiko API (OLAP v2, структура запросов, аутентификация, поля)

При работе с проблемами сортировки в DataLens или интеграцией с iiko API обращайся к этому файлу за справочной информацией.

---

**Примечание:** Этот файл — главный промпт для AI. Он всегда применяется ко всем чатам в этом workspace. Для изменения контекста редактируй этот файл.
