# datalens-iiko-etl

Проект построения управленческого дашборда по инвентаризациям для анализа недостач/излишков, превышений норм отклонений и ключевых источников потерь по неделям и филиалам.

> **Главный промпт для AI** — в `.cursor/rules/project.mdc`; актуализация README/readme по правилам оттуда.

## Цель проекта

Построить управленческий дашборд по инвентаризациям, который:

- Показывает топы расхождений в qty и в деньгах
- Отсеивает мусор (микродвижения, мармелад и т.п.)
- Корректно работает с филиалами
- Позволяет видеть потенциальные потери в месяц и анализировать подозрительные позиции (ошибка предыдущей инвентаризации)
- В будущем — динамика по товарам по неделям

Всё это: по неделям, по филиалам, без задвоений, с корректной логикой инвентаризаций.

## Архитектура

**Поток данных:**
```
iiko OLAP → inventory_raw.olap_postings (RAW)
   → inventory_core (очистка + агрегации + логика)
   → inventory_mart (витрины под DataLens)
   → DataLens (дашборды)
```
**Принцип:** Core — логика, Mart — формат, DataLens — визуал. Не тащить бизнес-логику в BI, не ломать core ради визуала.

## Структура проекта

```
datalens-iiko-etl/
├── .cursor/
│   └── rules/
│       └── project.mdc          # Главный промпт для AI (alwaysApply: true)
├── .github/
│   └── workflows/
│       └── etl.yml              # GitHub Actions workflow для автоматического запуска
├── etl.py                       # Основной ETL скрипт (загрузка из iiko в Neon)
├── requirements.txt             # Python зависимости
└── README.md                    # Этот файл
```

## Описание компонентов

### `etl.py`
Основной скрипт ETL-процесса:
- Загрузка конфигурации из переменных окружения
- Аутентификация в iiko API
- Запрос данных через OLAP API за период (вторник → понедельник предыдущей недели)
- Нормализация данных и вычисление `source_hash` для защиты от дублей
- Загрузка в PostgreSQL (Neon) в таблицу `inventory_raw.olap_postings`

### `.github/workflows/etl.yml`
GitHub Actions workflow для автоматического запуска:
- Ручной запуск через `workflow_dispatch`
- Установка Python 3.11 и зависимостей
- Выполнение `etl.py` с переменными окружения из GitHub Secrets

## Структура данных в Neon (Postgres)

- **`docs/neon-tables.md`** — список таблиц и колонок. **`docs/neon-schema.sql`** — полный DDL схем (CREATE TABLE/VIEW, функции), чтобы править объекты по коду. Обновить: workflow **Dump Neon schema** в Actions (выгружает оба) или локально `python scripts/dump_neon_schema.py` и `python scripts/dump_neon_ddl.py` (для DDL нужен pg_dump в PATH).

### 1. RAW — `inventory_raw.olap_postings`
- Все проводки iiko. Типы транзакций: WRITEOFF, PRODUCTION, OUTGOING_INVOICE, SESSION_WRITEOFF, INVENTORY_CORRECTION, **INVOICE** (приход).
- Защита от дублей: `source_hash` (ON CONFLICT DO NOTHING).

### 2. CORE — `inventory_core.*`
- `transactions` / `transactions_products` — нормализованная лента, SIGNED-логика.
- `weekly_movement_products` — движение по товарам (базовая витрина).
- `inventory_correction_clean_products` — ОЧИЩЕННАЯ инвентаризация (только итоговая).
- Флаги: «неверно посчитано в прошлой инвентаризации», несохранённые позиции (есть движение, нет INVENTORY_CORRECTION).

### 3. MART — `inventory_mart.*` (витрины под DataLens)
- `weekly_deviation_products_money_v2`, `weekly_deviation_products_qty`, `sandbox_inventory_products`.
- Поля: `is_wrong_prev_inventory`, `is_missing_inventory_position`, `week_label` (например Н5 (20.01–26.01)), `week_num`.
- ⚠️ При изменении колонок: **DROP + CREATE**. Не пересоздавать mart без проверки зависимостей. **Не использовать DROP CASCADE** без понимания.

## DataLens — структура

**Три вкладки дашборда:**
1. **Итоговая инвентаризация** — деньги, %, потенциальные потери; фильтр по филиалу; выбор недели и диапазона дат.
2. **Анализ пути товара** — документы (INVOICE, PRODUCTION, WRITEOFF, OUTGOING_INVOICE), `qty_signed`, `money_signed`; фильтр по периоду.
3. **Песочница** — объединение money + qty, полный доступ к данным.

**Датасеты:** MONEY и QTY с жёстко агрегированными мерами (_sum) в чартах; alias по department. **Фильтр по периоду — по week_start**, не по строковому week_label. Сортировка — только обычная таблица (поле в строках + сортировка + дубликат столбца).

## Переменные окружения

**Neon (PostgreSQL):**
- `NEON_HOST`, `NEON_DB`, `NEON_USER`, `NEON_PASSWORD`

**iiko API:**
- `IIKO_BASE_URL`, `IIKO_LOGIN`, `IIKO_PASS_SHA1`, `IIKO_VERIFY_SSL`

**Отчет:**
- `REPORT_ID` — идентификатор отчета
- `TRANSACTION_TYPES` — типы транзакций (через запятую или точку с запятой)
- `PRODUCT_TYPES` — типы продуктов (через запятую или точку с запятой)

**Опционально:**
- `RAW_DIR` — директория для сырых данных (по умолчанию `src/data/raw`)
- **Выгрузка прошлых периодов:** `DATE_FROM` и `DATE_TO` (формат `YYYY-MM-DD`). Конечная дата в iiko **исключающая** — день `date_to` не включается. Для недели 20.01–26.01 задавать **date_to = 27.01**, иначе инвентаризация не попадёт. В GitHub Actions — поля date_from, date_to при Run workflow.

## Локальный запуск

1. Установить зависимости: `pip install -r requirements.txt`
2. Создать `.env` файл с переменными окружения (см. выше)
3. Запустить: `python etl.py`

## Особенности

- **Идемпотентность:** защита от дублей через `source_hash` (ON CONFLICT DO NOTHING)
- **Автоматический период:** вычисление периода "вторник → понедельник" предыдущей закрытой недели
- **Обработка таймзон:** автоматическое определение и нормализация времени (UTC для БД)
- **Фильтрация:** исключение строк "Итого"/"Всего" из данных
- **Логика инвентаризаций:** учитываются только итоговые инвентаризации (понедельник 23:59:59), промежуточные игнорируются

## Текущий статус

**Реализовано:** ETL с ручным периодом и INVOICE; RAW → CORE → MART → DataLens; флаги неверного пересчёта и несохранённых позиций; три вкладки дашборда (Итоговая инвентаризация, Анализ пути товара, Песочница). Система даёт: системные отклонения, неверно пересчитанные и несохранённые позиции, путь документа, приходы/списания, анализ нескольких недель.

**Ошибки, которых избегать:** (1) Период — date_to не входит, для полной недели +1 день. (2) Рекурсия во вьюхах — не ссылаться на создаваемую вьюху. (3) DROP CASCADE — проверять зависимости. (4) Фильтр по периоду — по week_start, не по week_label. (5) Эталон филиала — сравнивать движение vs inventory_correction, не по количеству позиций.
